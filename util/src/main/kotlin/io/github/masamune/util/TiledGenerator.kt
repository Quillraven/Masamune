package io.github.masamune.util

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonPrimitive
import java.io.File

@Serializable
data class Member(
    val name: String,
    val type: String,
    val value: JsonPrimitive,
) {
    val kotlinType: String = when (type) {
        "string", "color" -> "String"
        "bool" -> "Boolean"
        "float" -> "Float"
        else -> error("Unsupported type: $type")
    }

    val kotlinValue: String = when (type) {
        "string", "color" -> "\"${value.content}\""
        "float" -> "${value.content}f"
        else -> value.content
    }
}

@Serializable
data class PropertyType(
    val id: Int,
    val name: String,
    val type: String,
    val values: List<String> = emptyList(),
    val members: List<Member> = emptyList(),
)

@Serializable
data class TiledProject(
    val propertyTypes: List<PropertyType>,
)

fun main() {
    val file = File("../masamune-tiled.tiled-project")

    println("Reading file ${file.name}")
    val jsonStr = file.readText()

    println("Parsing Json content")
    val json = Json {
        ignoreUnknownKeys = true
    }
    val tiledProject = json.decodeFromString<TiledProject>(jsonStr)

    println("Generating enums")
    tiledProject.propertyTypes
        .filter { it.type == "enum" && it.values.isNotEmpty() }
        .forEach { createEnum(it.name, it.values) }

    println("Generating property extensions")
    val extensionContent = createPropertyExtensionsHeader()
    // name of tiled classes to process
    listOf("MapObject" to "TiledMapTile", "FixtureDefinition" to "MapObject").forEach { (tiledClass, gdxClass) ->
        val properties = tiledProject.propertyTypes
            .first { it.name == tiledClass && it.members.isNotEmpty() }
            .members
        createPropertyExtensions(extensionContent, properties, gdxClass)
    }
    createPropertyExtensionsFile(extensionContent)
}

fun createEnum(name: String, values: List<String>) {
    // map of 'tiled enum name' to 'kotlin class name'
    // if map does not contain the tiled name then nothing will be generated
    val supportedEnums = mapOf(
        "MapObjectType" to "TiledObjectType",
    )
    val enumName = supportedEnums[name] ?: return

    println("Creating enum $enumName with values $values")
    val enumTargetPackage = "io/github/masamune/tiledmap"
    val enumFile = File("../core/src/main/kotlin/$enumTargetPackage/$enumName.kt")
    if (enumFile.exists()) {
        enumFile.delete()
    }
    enumFile.createNewFile()

    val content = buildString {
        val newLine = System.lineSeparator()
        append("package io.github.masamune.tiledmap").append(newLine).append(newLine)
        append("// This is an autogenerated class by gradle's 'genTiledEnumsAndExtensions' task. Do not touch it!").append(
            newLine
        )
        append("enum class $enumName {").append(newLine)
        append(values.sorted().joinToString(separator = ",$newLine    ", prefix = "    ")).append(newLine)
        append("}").append(newLine)
    }

    enumFile.writeText(content)
}

fun createPropertyExtensionsHeader(): StringBuilder {
    return StringBuilder().apply {
        val newLine = System.lineSeparator()
        append("package io.github.masamune.tiledmap").append(newLine).append(newLine)
        append("import com.badlogic.gdx.maps.MapObject").append(newLine)
        append("import com.badlogic.gdx.maps.tiled.TiledMapTile").append(newLine)
        append("import ktx.tiled.property").append(newLine).append(newLine)
        append("import ktx.tiled.propertyOrNull").append(newLine).append(newLine)
        append("// This is an autogenerated file by gradle's 'genTiledEnumsAndExtensions' task. Do not touch it!")
    }
}

fun createPropertyExtensionsFile(content: StringBuilder) {
    val targetPackage = "io/github/masamune/tiledmap"
    val targetFile = File("../core/src/main/kotlin/$targetPackage/tiledProperties.kt")
    if (targetFile.exists()) {
        targetFile.delete()
    }
    targetFile.createNewFile()
    content.append(System.lineSeparator())
    targetFile.writeText(content.toString())
}

fun createPropertyExtensions(content: StringBuilder, properties: List<Member>, gdxClass: String) {
    println("Creating property extensions for ${properties.map(Member::name)} and class $gdxClass")

    with(content) {
        val newLine = System.lineSeparator()

        properties.forEach { property ->
            append(newLine).append(newLine)
            if (property.name == "userData") {
                // special case with String? and propertyOrNull ktx call
                append("val $gdxClass.${property.name}: ${property.kotlinType}?").append(newLine)
                append("    get() = this.propertyOrNull<${property.kotlinType}>(\"${property.name}\")")
                return@forEach
            }

            append("val $gdxClass.${property.name}: ${property.kotlinType}").append(newLine)
            append("    get() = this.property<${property.kotlinType}>(\"${property.name}\", ${property.kotlinValue})")
        }
    }
}
