package io.github.masamune.util

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonPrimitive
import java.io.File

@Serializable
data class Member(
    val name: String,
    val type: String,
    val value: JsonPrimitive,
) {
    val kotlinType: String = when (type) {
        "string", "color" -> "String"
        "bool" -> "Boolean"
        "float" -> "Float"
        else -> error("Unsupported type: $type")
    }

    val kotlinValue: String = when (type) {
        "string", "color" -> "\"${value.content}\""
        "float" -> "${value.content}f"
        else -> value.content
    }
}

@Serializable
data class PropertyType(
    val id: Int,
    val name: String,
    val type: String,
    val values: List<String> = emptyList(),
    val members: List<Member> = emptyList(),
)

@Serializable
data class TiledProject(
    val propertyTypes: List<PropertyType>,
)

fun main() {
    val file = File("../masamune-tiled.tiled-project")

    println("Reading file ${file.name}")
    val jsonStr = file.readText()

    println("Parsing Json content")
    val json = Json {
        ignoreUnknownKeys = true
    }
    val tiledProject = json.decodeFromString<TiledProject>(jsonStr)

    println("Generating enums")
    tiledProject.propertyTypes
        .filter { it.type == "enum" && it.values.isNotEmpty() }
        .forEach { createEnum(it.name, it.values) }

    println("Generating property extensions")
    val properties = tiledProject.propertyTypes
        .first { it.name == "MapObject" && it.members.isNotEmpty() }
        .members
    createPropertyExtensions(properties)
}

fun createEnum(name: String, values: List<String>) {
    // map of 'tiled enum name' to 'kotlin class name'
    // if map does not contain the tiled name then nothing will be generated
    val supportedEnums = mapOf(
        "MapObjectType" to "TiledObjectType",
    )
    val enumName = supportedEnums[name] ?: return

    println("Creating enum $enumName with values $values")
    val enumTargetPackage = "io/github/masamune/tiledmap"
    val enumFile = File("../core/src/main/kotlin/$enumTargetPackage/$enumName.kt")
    if (enumFile.exists()) {
        enumFile.delete()
    }
    enumFile.createNewFile()

    val content = buildString {
        val newLine = System.lineSeparator()
        append("package io.github.masamune.tiledmap").append(newLine).append(newLine)
        append("// This is an autogenerated class by gradle's 'genTiledEnums' task. Do not touch it!").append(newLine)
        append("enum class $enumName {").append(newLine)
        append(values.sorted().joinToString(separator = ",$newLine    ", prefix = "    ")).append(newLine)
        append("}").append(newLine)
    }

    enumFile.writeText(content)
}

fun createPropertyExtensions(properties: List<Member>) {
    println("Creating property extensions for ${properties.map(Member::name)}")
    val targetPackage = "io/github/masamune/tiledmap"
    val targetFile = File("../core/src/main/kotlin/$targetPackage/tiledProperties.kt")
    if (targetFile.exists()) {
        targetFile.delete()
    }
    targetFile.createNewFile()

    val content = buildString {
        val newLine = System.lineSeparator()
        append("package io.github.masamune.tiledmap").append(newLine).append(newLine)
        append("import com.badlogic.gdx.maps.tiled.TiledMapTile").append(newLine)
        append("import ktx.tiled.property").append(newLine).append(newLine)
        append("// This is an autogenerated file by gradle's 'genTiledEnums' task. Do not touch it!")
        append(newLine).append(newLine)

        properties.forEach { property ->
            append("val TiledMapTile.${property.name}: ${property.kotlinType}").append(newLine)
            if (property.value.content.isBlank()) {
                append("    get() = this.property<${property.kotlinType}>(\"${property.name}\")")
            } else {
                append("    get() = this.property<${property.kotlinType}>(\"${property.name}\", ${property.kotlinValue})")
            }
            append(newLine).append(newLine)
        }
        append(newLine)
    }

    targetFile.writeText(content)
}
